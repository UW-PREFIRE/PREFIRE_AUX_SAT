# Note: the "pseudo-swath" idea is no longer being actively developed at
# this time (2023-01-11), and none of the core Aux-JPSS code depends on this 
# script. This script is left in the repo for reference in case the pseudo-swath
# idea is pursued in the future.

import argparse
import h5py as h
import netCDF4 as n
import numpy as np
from shapely import geometry, ops

CORNERS = ["NE", "SE", "NW", "SW"]


def init_tirs_data(prefire_file):
    """
    Extract the four corners of each footprint, generating
    linestrings for each respective corner in each scan.
    """
    print("Initializing TIRS geo data")
    plon_v = prefire_file["Geometry"]["longitude_vertices"][:]
    plat_v = prefire_file["Geometry"]["latitude_vertices"][:]
    shapes = np.shape(plon_v)

    assert shapes == np.shape(
        plat_v
    ), "PREFIRE lon and lat verticies not the same shape"
    assert len(shapes) == 3, "PREFIRE data should be Nscan x Nfootprint x Ncorner"

    geo_data = {x: [] for x in CORNERS}

    for i in range(shapes[0]):
        for ic, c in enumerate(CORNERS):
            geo_data[c].append(
                geometry.LineString(
                    [(x, y) for x, y in zip(plon_v[i, :, ic], plat_v[i, :, ic])]
                )
            )

    return geo_data


def generate_pseudo_footprints(input_geometries, pseudo_footprint_count):
    """
    Create a track of pseudo-footprints based on the specified count input.
    The corners of each pseudo-footprint is based on a fractional substring
    of a LineString generated by each respective corner of the original
    footprints (e.g. NW corner of pseudo-footprints is created by substrings
    of the NW corner LineString). The output geometries are defined in the
    same directional manner.
    """
    print("Creating pseudo footprints")
    n_tracks = len(input_geometries["NW"])
    output_geometries = {
        "longitude": np.full([n_tracks, pseudo_footprint_count, 4], np.nan),
        "latitude": np.full([n_tracks, pseudo_footprint_count, 4], np.nan),
    }

    for i in range(n_tracks):
        # Iterate over all but one of the pseudo footprint count. Because
        # we always choose the pseudo footprint as the first of the two
        # results in the ops.substring command, we want to simply grab
        # the second part of the substring on the final iteration.
        for j in range(pseudo_footprint_count-1):
            frac = float(j / pseudo_footprint_count-1)
            frac_p_1 = float((j + 1) / pseudo_footprint_count-1)
            t = {
                x: ops.substring(
                    input_geometries[x][i], frac, frac_p_1, normalized=True
                )
                for x in CORNERS
            }
            output_geometries["longitude"][i, j, :] = [
                t[x].coords[0][0] for x in CORNERS
            ]
            output_geometries["latitude"][i, j, :] = [
                t[x].coords[0][1] for x in CORNERS
            ]
        output_geometries["longitude"][i, j+1, :] = [
            t[x].coords[1][0] for x in CORNERS
        ]
        output_geometries["latitude"][i, j+1, :] = [
            t[x].coords[1][1] for x in CORNERS
        ]

    return output_geometries


def write_pseudo_tirs_data(output_fpath, tirs_pseudo_geo):
    print("Writing out pseudo TIRS data")
    shapes = np.shape(tirs_pseudo_geo["longitude"])
    assert (
        len(shapes) == 3
    ), "PREFIRE pseudo data should be Nscan x Nfootprint x Ncorner"
    with n.Dataset(output_fpath, "w") as out_f:
        dim_ntrack = out_f.createDimension("Ntrack", shapes[0])
        dim_nscan = out_f.createDimension("Npseudoscan", shapes[1])
        dim_ncorn = out_f.createDimension("Ncorners", shapes[2])
        grp = out_f.createGroup("Geometry")
        lon = grp.createVariable(
            "longitude_vertices",
            "f8",
            ("Ntrack", "Npseudoscan", "Ncorners"),
            fill_value=-9999,
        )
        lat = grp.createVariable(
            "latitude_vertices",
            "f8",
            ("Ntrack", "Npseudoscan", "Ncorners"),
            fill_value=-9999,
        )
        lon[:] = tirs_pseudo_geo["longitude"]
        lat[:] = tirs_pseudo_geo["latitude"]


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "out_file",
        help="provide path and name for output file",
    )
    parser.add_argument("tirs_file", help="provide path and name for TIRS file input")
    parser.add_argument(
        "n_footprints", help="provide number of footprints to generate per scan"
    )
    args = parser.parse_args()

    return args.out_file, args.tirs_file, int(args.n_footprints)


def main():
    out_fpath, tirs_fpath, pseudo_footprint_count = parse_args()

    with h.File(tirs_fpath, "r") as tirs_f:
        tirs_geo = init_tirs_data(tirs_f)

    tirs_pseudo_geo = generate_pseudo_footprints(tirs_geo, pseudo_footprint_count)
    write_pseudo_tirs_data(out_fpath, tirs_pseudo_geo)


if __name__ == "__main__":
    main()
